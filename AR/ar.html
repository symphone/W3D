<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR</title>
  <style>
    html {
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>

  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/mmdparser.min.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/libs/ammo.js"></script>

  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/TGALoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MMDLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/effects/OutlineEffect.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/CCDIKSolver.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDPhysics.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/animation/MMDAnimationHelper.js"></script>
  <!-- ar.js -->
  <script src="build/ar.js"></script>
  <script>THREEx.ArToolkitContext.baseURL = ''</script>
  <script type="text/javascript">
  
	class Button {
		constructor (size, x, y){
			this.size = size;
			this.centerX = x;
			this.centerY = y;
		}
		d1To (v) { // 1-norm
			return Math.abs (v[0]-this.centerX) + Math.abs(v[1]-this.centerY);
		}
		d2To (v) { // 2-norm
			return Math.sqrt ( (v[0]-this.centerX)*(v[0]-this.centerX) 
					+ (v[1]-this.centerY)*(v[1]-this.centerY) );
		}
		dInfTo (v) { // inf-norm
			return Math.max( Math.abs (v[0]-this.centerX), Math.abs(v[1]-this.centerY) )
		}
	}
  
    var frame, scene, camera, renderer, light, controls;
    var arToolkitSource, arToolkitContext, markeHiro;
    var stats;
    var helper, ikHelper, physicsHelper, effect;
    var modelFile = 'models/serval/serval.pmx';
    var vmdFiles = ['vmds/servaldance.vmd'];
    var vpdFiles = ['vpds/sing.vpd'];
    var clock = new THREE.Clock();
    var meshs = [];
    var myActions = [],
      settings;
	//HUD
	var whRatio, halfW, halfH;
	var button, button1;

    Ammo().then(function(AmmoLib) {
      Ammo = AmmoLib;
      init();
      animate();
    });


    function init() {
		let _iOSDevice = !!navigator.platform.match(/iPhone|iPod|iPad/);

      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(new THREE.Color('lightgrey'), 0);
      renderer.domElement.style.position = 'absolute'
    	renderer.domElement.style.top = '0px'
    	renderer.domElement.style.left = '0px'
      document.body.appendChild(renderer.domElement);

      scene = new THREE.Scene();

    /*  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.position.z = 20;*/
      camera = new THREE.Camera();
	    scene.add(camera);

      ////////////////////////////////////////////////////////////////////////////////
    	//          handle arToolkitSource
    	////////////////////////////////////////////////////////////////////////////////
    	arToolkitSource = new THREEx.ArToolkitSource({
    		// to read from the webcam
    		sourceType : 'webcam',

    		// // to read from an image
    		// sourceType : 'image',
    		// sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/images/img.jpg',
    		// to read from a video
    		// sourceType : 'video',
    		// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    	})
    	arToolkitSource.init(function onReady(){
    		onResize()
    	})

    	// handle resize
    	window.addEventListener('resize', function(){
    		onResize()
    	})
    	////////////////////////////////////////////////////////////////////////////////
    	//          initialize arToolkitContext
    	////////////////////////////////////////////////////////////////////////////////

      // create atToolkitContext
    	arToolkitContext = new THREEx.ArToolkitContext({
    		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/data/camera_para.dat',
    		detectionMode: 'mono',
        maxDetectionRate: 30,
        canvasWidth:80*3,
        canvasHeight: 60*3,
    	})
    	// initialize it
    	arToolkitContext.init(function onCompleted(){
    		// copy projection matrix to camera
    		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    	})
      markeHiro = addMarkeHiro();
      scene.add(markeHiro);
      ////////////////////////////////////////////////////////////////////////////////
      stats = new Stats();
      stats.showPanel(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';
      document.body.appendChild(stats.domElement);
    //  controls = new THREE.OrbitControls(camera, renderer.domElement);

      effect = new THREE.OutlineEffect(renderer);

      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(50, 100, 0);
      markeHiro.add(light);


      ///model

      function onProgress(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };

      function onError(xhr) {};

      var loader = new THREE.MMDLoader();
      console.log(modelFile);

      helper = new THREE.MMDAnimationHelper({
        afterglow: 2.0
      });

      loader.loadWithAnimation(modelFile,vmdFiles,
        function(mmd) {
          function loadEnd(_mmd) {
            mesh = _mmd.mesh;
            mesh.scale.set(0.1, 0.1, 0.1);
            meshs.push(mesh);
            markeHiro.add(mesh);

            helper.add(mesh, {
              animation: _mmd.animation,
              physics: true
            });


            ikHelper = helper.objects.get(mesh).ikSolver.createHelper();
            ikHelper.visible = false;
            scene.add(ikHelper);

            physicsHelper = helper.objects.get(mesh).physics.createHelper();
            physicsHelper.visible = false;
            scene.add(physicsHelper);

          };
          setTimeout(loadEnd(mmd), 10);
        },
        onProgress, onError);

		// for HUD scene
		sceneHUD = new THREE.Scene();
		
		// eye-coordinate bounds
		halfH = 10;
		halfW = halfH * whRatio;
		
		cameraHUD = new THREE.OrthographicCamera (-halfW,halfW, halfH,-halfH, -10,10);


		////////////////////////////////////////////////////
		// create a button to toggle rotation
		//
		var buttonSize = halfH/3;
		button = new THREE.Mesh (new THREE.PlaneGeometry(buttonSize, buttonSize), 
				new THREE.MeshBasicMaterial({color:"yellow", transparent:true, opacity:0.8}));	
		button1 = new Button (buttonSize, 0, -halfH/2);
		button.position.set (button1.centerX, button1.centerY, 0);
		sceneHUD.add (button);
	  
	  
		if (_iOSDevice)
			window.addEventListener('touchstart', onTouchStart, false);
		else
			window.addEventListener ('mousedown', onMouseDown, false);

    }
	
	function onResize(){
		arToolkitSource.onResize()	
		arToolkitSource.copySizeTo(renderer.domElement)	
		if( arToolkitContext.arController !== null ){
			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
		}	
		
		//$('#ratio').text ('resize: width: ' + window.innerWidth + ' height: ' + window.innerHeight)
		
		whRatio = window.innerWidth/window.innerHeight;
		 halfW = halfH * whRatio;
		cameraHUD.left = -halfW;
		cameraHUD.right = halfW;
		cameraHUD.top = halfH;
		cameraHUD.bottom = -halfH;
		//cameraHUD.updateProjectionMatrix();
		// ideally, this is needed, 
		// but commented out gives better result (in Chrome emulator)
		
		
	/*	
	  AR world resize: controlled by arToolKit
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	*/  
	  //renderer.setSize(window.innerWidth, window.innerHeight);
			
	}

    function animate() {
      stats.begin();
      stats.end();
      requestAnimationFrame(animate);
      if(arToolkitSource.ready === false) return;
      arToolkitContext.update(arToolkitSource.domElement);

      render();
    }

    function render() {
      renderer.render(scene, camera);
      helper.update(clock.getDelta());
      effect.render(scene, camera);
    }

    function addMarkeHiro(){
      let markerRoot = new THREE.Group();
      var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
    		type : 'pattern',
    		patternUrl : THREEx.ArToolkitContext.baseURL + 'data/data/patt.hiro'
    		// patternUrl : THREEx.ArToolkitContext.baseURL + 'data/data/patt.kanji'
    	})

      return markerRoot;
    }
	
	function pickCompute (ndcX, ndcY) {

		// use 2D algorithm 	
		let dist = button1.dInfTo ([halfW * ndcX, halfH * ndcY]);	
		//$('#touch').text ('Mouse-dist-Button: ' + dist.toFixed(2))
		
		if (dist < button1.size/2) {
			console.log ('picked')
			cubeSpin = !cubeSpin;
		} else {
			console.log ('no hit')
		}

	}

	function onMouseDown (event) {
		console.log ('in mouse down')
		event.preventDefault();
		let ndcX = (event.clientX / window.innerWidth) * 2 - 1;
		let ndcY = -(event.clientY / window.innerHeight) * 2 + 1;

		pickCompute (ndcX, ndcY);		
	}	

	function onTouchStart (event) {
		console.log ('in touch start')

	   if (event.touches.length == 1) {
			
			event.preventDefault();
			let ndcX = ( event.touches[0].pageX / window.innerWidth ) * 2 - 1;
			let ndcY = - ( event.touches[0].pageY / window.innerHeight ) * 2 + 1;
		
			pickCompute (ndcX, ndcY);		
			
		}	
	}
  </script>
</body>
</html>
