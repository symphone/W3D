<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR</title>
</head>
<body>
<div style="float:right">
  <button type="button" id="hb"><img src="https://i.imgur.com/EWz4ttH.jpg" style="height:40px; width:40px"></button>
  <button type="button" id="d"><img src="https://i.imgur.com/OQi0E1e.jpg" style="height:40px; width:40px"></button>
  <button type="button" id="c"><img src="https://i.imgur.com/UNsgykn.jpg" style="height:40px; width:40px"></button>
</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/MTLLoader.js"></script>
  <script src="https://rawgit.com/mrdoob/three.js/master/examples/js/loaders/OBJLoader.js"></script>
  <!-- ar.js -->
  <script src="../build/ar.js"></script>
  <script>THREEx.ArToolkitContext.baseURL = '../'</script>
  <!-- -->
  <script type="text/javascript">
    var frame, scene, camera, renderer, light, controls;
    var arToolkitSource, arToolkitContext, markeHiro;
    var stats
    var models = ['Hamburger', 'Donitsi', 'cake'], ready = false;
	var cur = 0;
	$('#foodB').click(function(){
		console.log("food")
	})
	$('#hb').click(function(){
		console.log("hamburger")
		let selectedObject = markeHiro.getObjectByName(models[cur]);
		markeHiro.remove(selectedObject);
		cur = 0;
		readModel(models[cur]);
	});
	$('#d').click(function(){
		console.log("dontist")
		let selectedObject = markeHiro.getObjectByName(models[cur]);
		markeHiro.remove(selectedObject);
		cur = 1;
		readModel(models[cur]);
	});
	$('#c').click(function(){
		console.log("cake")
		let selectedObject = markeHiro.getObjectByName(models[cur]);
		markeHiro.remove(selectedObject);
		cur = 2;
		readModel(models[cur]);
	});
	/*$(function(){
        ////切換model
        for(let i=0;i<models.length;i++){
          let pic = '#pic' + i;
           $(pic).click(function(){
             if(mySelector != i){
               ready = false;
               let selectedObject = markeHiro.getObjectByName(models[mySelector]);
               markeHiro.remove(selectedObject);
               mySelector = i;
               readModel(models[mySelector]);
             };
           });
         };
    });*/
	
    init();
    animate();
    function init() {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(new THREE.Color('lightgrey'), 0);
      //renderer.domElement.style.position = 'absolute'
    	renderer.domElement.style.top = '0px'
    	renderer.domElement.style.left = '0px'
      document.body.appendChild(renderer.domElement);
      scene = new THREE.Scene();
      camera = new THREE.Camera();
	    scene.add(camera);
      ////////////////////////////////////////////////////////////////////////////////
    	//          handle arToolkitSource
    	////////////////////////////////////////////////////////////////////////////////
    	arToolkitSource = new THREEx.ArToolkitSource({
    		// to read from the webcam
    		sourceType : 'webcam',
    		// // to read from an image
    		// sourceType : 'image',
    		// sourceUrl : THREEx.ArToolkitContext.baseURL + 'data/images/HIRO.jpg',
    		// to read from a video
    		// sourceType : 'video',
    		// sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',
    	})
    	arToolkitSource.init(function onReady(){
    		onResize()
    	})
    	// handle resize
    	window.addEventListener('resize', function(){
    		onResize()
    	})
    	function onResize(){
    		arToolkitSource.onResize()
    		arToolkitSource.copySizeTo(renderer.domElement)
    		if( arToolkitContext.arController !== null ){
    			arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
    		}
    	}
    	////////////////////////////////////////////////////////////////////////////////
    	//          initialize arToolkitContext
    	////////////////////////////////////////////////////////////////////////////////
      // create atToolkitContext
    	arToolkitContext = new THREEx.ArToolkitContext({
    		cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'data/data/camera_para.dat',
    		detectionMode: 'mono',
        maxDetectionRate: 30,
        canvasWidth:80*3,
        canvasHeight: 60*3,
    	})
    	// initialize it
    	arToolkitContext.init(function onCompleted(){
    		// copy projection matrix to camera
    		camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
    	})
      markeHiro = addMarkeHiro();
      scene.add(markeHiro);
      ////////////////////////////////////////////////////////////////////////////////
      stats = new Stats();
      stats.showPanel(0);
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';
      document.body.appendChild(stats.domElement);
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(5, 10, 0);
      markeHiro.add(light);
      let light2 = new THREE.AmbientLight( 0x444444 );
      markeHiro.add( light2 );
	  let plane = new THREE.Mesh( new THREE.CircleGeometry(0.7, 20), new THREE.MeshPhongMaterial({color:'#bababa'}) );
      plane.rotation.x = -Math.PI/2;
      markeHiro.add(plane);
      /////Models
      readModel(models[cur]);
    }
    function animate() {
      stats.begin();
      stats.end();
      requestAnimationFrame(animate);
      if(arToolkitSource.ready === false) return;
      arToolkitContext.update(arToolkitSource.domElement);
      if(ready){
        frame.rotation.y += 0.01;
	  }
      render();
    }
    function render() {
      renderer.render(scene, camera);
    }
    function addMarkeHiro(){
      let markerRoot = new THREE.Group();
      var artoolkitMarker = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
    		type : 'pattern',
    		patternUrl : THREEx.ArToolkitContext.baseURL + 'data/data/patt.hiro'
    		// patternUrl : THREEx.ArToolkitContext.baseURL + 'data/data/patt.kanji'
    	})
      return markerRoot;
    }
    ///model
    function readModel(modelName, targetSize = 1) {
      var onProgress = function(xhr) {
        if (xhr.lengthComputable) {
          var percentComplete = xhr.loaded / xhr.total * 100;
          console.log(Math.round(percentComplete, 2) + '% downloaded');
        }
      };
      var onError = function(xhr) {};
      var mtlLoader = new THREE.MTLLoader();
      mtlLoader.setPath('models/');
      mtlLoader.load(modelName + '.mtl', function(materials) {
        materials.preload();
        var objLoader = new THREE.OBJLoader();
        objLoader.setMaterials(materials);
        objLoader.setPath('models/');
        objLoader.load(modelName + '.obj', function(object) {
          let theObject = unitize(object, targetSize);
          //theObject.rotation.x = Math.PI / 2;
          theObject.name = modelName;
          markeHiro.add(theObject);
          frame = theObject;
          ready = true;
        }, onProgress, onError);
      });
    }
    function unitize(object, targetSize) {
      // find bounding box of 'object'
      var box3 = new THREE.Box3();
      box3.setFromObject(object);
      var size = new THREE.Vector3();
      size.subVectors(box3.max, box3.min);
      var center = new THREE.Vector3();
      center.addVectors(box3.max, box3.min).multiplyScalar(0.5);
      console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
      console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);
      // uniform scaling according to objSize
      var objSize = Math.max(size.x, size.y, size.z);
      var scaleSet = targetSize / objSize;
      var theObject = new THREE.Object3D();
      theObject.add(object);
      object.scale.set(scaleSet, scaleSet, scaleSet);
      object.position.set(-center.x * scaleSet, -center.y * scaleSet + 0.1 , -center.z * scaleSet);
      return theObject;
    }
  </script>
</body>
</html>